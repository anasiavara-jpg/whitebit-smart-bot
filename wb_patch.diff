--- main.py
+++ main.py
@@
 def _normalize_market_cfg(cfg: dict) -> dict:
@@
     cfg.setdefault("hold_on_sl", False)    # —è–∫—â–æ True ‚Äî –ø—Ä–∏ SL –ù–ï –ø—Ä–æ–¥–∞—î–º–æ, –∞ —Ç—Ä–∏–º–∞—î–º–æ –º–æ–Ω–µ—Ç–∏
     cfg.setdefault("holdings_lock", False) # –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ–π –ø—Ä–∞–ø–æ—Ä: –º–æ–Ω–µ—Ç–∏ ¬´–∑–∞–º–æ—Ä–æ–∂–µ–Ω—ñ¬ª –¥–æ –∞–ø-—Ç—Ä–µ–Ω–¥—É
+    # --- –∞–≤—Ç–æ-–≤–∏–ø–ª–∞—Ç–∞ —á–∞—Å—Ç–∏–Ω–∏ TP –Ω–∞ main
+    cfg.setdefault("auto_payout_enabled", True)
+    cfg.setdefault("auto_payout_pct", 30.0)
     return cfg
@@
 async def get_balance() -> dict:
     data = await private_post("/api/v4/trade-account/balance")
     logging.info(f"DEBUG balance: {data}")
     return data if isinstance(data, dict) else {}
 
+async def transfer_trade_to_main_usdt(amount_usdt: Decimal) -> dict:
+    """
+    –ü–µ—Ä–µ–∫–∞–∑ –∑ trade-–∞–∫–∫–∞—É–Ω—Ç–∞ –Ω–∞ main —É USDT.
+    """
+    if amount_usdt <= 0:
+        return {"success": False, "message": "amount<=0"}
+    body = {"ticker": "USDT", "amount": str(amount_usdt), "from": "trade", "to": "main"}
+    return await private_post("/api/v4/main-account/transfer", body)
+
@@
 async def private_post(path: str, extra_body: Optional[dict] = None) -> dict:
     body_bytes, headers = _payload_and_headers(path, extra_body)
     url = BASE_URL + path
     for attempt in range(3):
         try:
             async with httpx.AsyncClient(timeout=30) as client:
-                r = await client.post(url, headers=headers, content=body_bytes)
+                r = await client.post(url, headers=headers, content=body_bytes)
+            # üëá –î–û–î–ê–ù–û: –¥–µ—Ç–∞–ª—å–Ω–∏–π –ª–æ–≥ –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ (422, —Ç–µ–∫—Å—Ç –ø—Ä–∏—á–∏–Ω–∏ —Ç–æ—â–æ)
+            try:
+                logging.info(f"[WB] {r.request.method} {url} -> {r.status_code} {r.text}")
+            except Exception:
+                pass
             if r.status_code == 429:
                 await asyncio.sleep(0.5 + 0.5 * attempt)
                 continue
             if r.status_code >= 500:
                 logging.warning(f"[private_post] {r.status_code} {url}")
@@
     return {"error": "private_post retries exceeded"}
@@
 def next_nonce() -> int:
@@
     return _nonce
+
+# ---- NEW: —É–Ω—ñ—Ñ—ñ–∫–æ–≤–∞–Ω–∞ –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è –º–∞—Ä–∫–µ—Ç–∞ (–¥–ª—è –∑—Ä—É—á–Ω–æ—Å—Ç—ñ –≤ —Ö–µ–Ω–¥–ª–µ—Ä–∞—Ö)
+def _norm_market_name(s: str) -> str:
+    return s.strip().upper().replace("-", "_").replace("/", "_")
@@
 async def place_limit_order(
@@
     return await private_post("/api/v4/order/new", body)
@@
 async def _place_maker_limit(market, side, price, amount, tag):
-    oid = _extract_order_id(
-        await place_limit_order(market, side, price, amount, client_order_id=tag, post_only=True)
-    )
-    return oid
+    """
+    –û–ù–û–í–õ–ï–ù–û: –≤—Ä–∞—Ö–æ–≤—É—î maker_only –∑ cfg —Ç–∞ —Ä–æ–±–∏—Ç—å —Ä–µ—Ç—Ä–∞–π –±–µ–∑ postOnly,
+    —è–∫—â–æ –±—ñ—Ä–∂–∞ –≤—ñ–¥—Ö–∏–ª–∏–ª–∞ post-only –ª—ñ–º—ñ—Ç (–∫–ª–∞—Å–∏—á–Ω–∞ 422 'would be filled immediately').
+    """
+    # —Å–ø—Ä–æ–±—É—î–º–æ –¥—ñ—Å—Ç–∞—Ç–∏ cfg –∑ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ markets, —è–∫—â–æ —î
+    cfg = markets.get(market, {}) if isinstance(markets.get(market), dict) else {}
+    post_only = bool(cfg.get("maker_only", True))
+
+    # 1-–∞ —Å–ø—Ä–æ–±–∞
+    res = await place_limit_order(
+        market, side, price, amount,
+        client_order_id=tag, post_only=post_only
+    )
+    oid = _extract_order_id(res)
+    if oid:
+        return oid
+
+    # –Ø–∫—â–æ –ø–æ–º–∏–ª–∫–∞ —É dict ‚Äî –¥–∏–≤–∏–º–æ—Å—å –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
+    if isinstance(res, dict):
+        msg = (res.get("message") or "").lower()
+        if (("post" in msg and "only" in msg) or ("would be filled" in msg)) and post_only:
+            logging.warning(f"[SCALP] {market} {side}: postOnly reject ‚Üí —Ä–µ—Ç—Ä–∞–π –±–µ–∑ postOnly")
+            res2 = await place_limit_order(
+                market, side, price, amount,
+                client_order_id=tag, post_only=False
+            )
+            oid2 = _extract_order_id(res2)
+            if oid2:
+                return oid2
+    return None
@@
     if cfg.get("tp"):
         tp_price = float(quantize_price(market, last_price * (1 + float(cfg["tp"]) / 100)))
         cfg["last_tp_price"] = tp_price
         cid = f"wb-{market}-tp-{ts}"
-        tp_order = await place_limit_order(market, "sell", tp_price, base_amount, client_order_id=cid)
-        oid = _extract_order_id(tp_order)
-        if oid:
-            cfg["orders"].append({"id": oid, "cid": cid, "type": "tp", "market": market})
+        tp_order = await place_limit_order(market, "sell", tp_price, base_amount, client_order_id=cid)
+        oid = _extract_order_id(tp_order)
+        if oid:
+            cfg["orders"].append({
+                "id": oid, "cid": cid, "type": "tp", "market": market,
+                "price": tp_price, "amount": float(base_amount)
+            })
@@
-        if oid:
-            cfg["orders"].append({"id": oid, "cid": cid, "type": "tp", "market": market})
+        if oid:
+            cfg["orders"].append({
+                "id": oid, "cid": cid, "type": "tp", "market": market,
+                "price": tp_price, "amount": float(safe_amount)
+            })
@@
 async def seed_scalp_grid(market: str, cfg: dict, ref_price: float):
@@
-        oid = await _place_maker_limit(market, "buy", p, float(amt), tag)
+        oid = await _place_maker_limit(market, "buy", p, float(amt), tag)
@@
-                oid = await _place_maker_limit(market, "sell", p, float(portion), tag)
+                oid = await _place_maker_limit(market, "sell", p, float(portion), tag)
                 if oid:
                     cfg["orders"].append({"id": oid, "type": "scalp_sell", "market": market, "price": p, "amount": float(portion)})
@@
     if typ == "scalp_buy":
         cfg["entry_price"] = price
         p_out = float(quantize_price(market, price * (1 + tick / 100)))
         tag = f"wb-{market}-pp-sell-{now_ms()}"
-        oid = await _place_maker_limit(market, "sell", p_out, amt, tag)
+        oid = await _place_maker_limit(market, "sell", p_out, amt, tag)
@@
-        oid = await _place_maker_limit(market, "buy", p_in, float(amt_in), tag)
+        oid = await _place_maker_limit(market, "buy", p_in, float(amt_in), tag)
@@
 @dp.message(Command("buy"))
 async def buy_cmd(message: types.Message):
     try:
-        _, market = message.text.split()
-        market = market.upper().replace("/", "_")
+        _, market = message.text.split()
+        market = _norm_market_name(market)
         if market not in markets:
             await message.answer("‚ùå –°–ø–æ—á–∞—Ç–∫—É –¥–æ–¥–∞–π —Ä–∏–Ω–æ–∫ —á–µ—Ä–µ–∑ /market.")
             return
         await start_new_trade(market, markets[market])
         await message.answer(f"‚úÖ –ö—É–ø—ñ–≤–ª—è {market} –≤–∏–∫–æ–Ω–∞–Ω–∞ –Ω–∞ {markets[market]['buy_usdt']} USDT.")
     except Exception:
         await message.answer("‚ö†Ô∏è –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è: /buy BTC/USDT")
+
+# ---- NEW: —à–≤–∏–¥–∫–∏–π —Å—Ç–∞—Ä—Ç —Ç–æ—Ä–≥—ñ–≤–ª—ñ –ø–æ —Ä–∏–Ω–∫—É
+@dp.message(Command("start_trade"))
+async def cmd_start_trade(message: types.Message):
+    parts = message.text.split()
+    if len(parts) < 2:
+        return await message.answer("‚ö†Ô∏è –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è: /start_trade BTC/USDT")
+    market = _norm_market_name(parts[1])
+    if market not in markets:
+        return await message.answer("‚ùå –°–ø–æ—á–∞—Ç–∫—É –¥–æ–¥–∞–π —Ä–∏–Ω–æ–∫ —á–µ—Ä–µ–∑ /market.")
+    ok = await start_new_trade(market, markets[market])
+    await message.answer("üü¢ –ó–∞–ø—É—â–µ–Ω–æ" if ok is None or ok else "‚ö†Ô∏è –ù–µ –≤–¥–∞–ª–æ—Å—è (–±–∞–ª–∞–Ω—Å/–ø—Ä–∞–≤–∏–ª–∞).")
+
+# ---- NEW: –º–∞—Å–æ–≤–µ —Å–∫–∞—Å—É–≤–∞–Ω–Ω—è –æ—Ä–¥–µ—Ä—ñ–≤ –ø–æ –≤—Å—ñ—Ö —Ä–∏–Ω–∫–∞—Ö
+@dp.message(Command("cancel_all"))
+async def cmd_cancel_all(message: types.Message):
+    total = 0
+    for m in list(markets.keys()):
+        if m == "_global":
+            continue
+        try:
+            data = await active_orders(m)
+            orders = data.get("orders", []) if isinstance(data, dict) else []
+            for o in orders:
+                oid = o.get("orderId") or o.get("id")
+                if oid:
+                    await cancel_order(m, order_id=str(oid))
+                    total += 1
+                    await asyncio.sleep(0.15)
+        except Exception as e:
+            logging.error(f"[cancel_all] {m}: {e}")
+    await message.answer(f"üßπ –°–∫–∞—Å–æ–≤–∞–Ω–æ –∑–∞–≥–∞–ª–æ–º {total} –æ—Ä–¥–µ—Ä(—ñ–≤)")
@@
 async def monitor_orders():
@@
-                                if want:
-                                    prof = cfg.get(f"profile_{want}") or {}
-                                    # –ø—ñ–¥–º—ñ–Ω–∞ —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –∑–Ω–∞—á–µ–Ω–Ω—è —î
-                                    for k in ("tp", "sl", "rebuy_pct", "scalp", "tick_pct", "levels"):
-                                        if k in prof:
-                                            cfg[k] = prof[k]
-                                    save_markets()
-                                                                    if want:
-                                    prof = cfg.get(f"profile_{want}") or {}
-                                    for k in ("tp", "sl", "rebuy_pct", "scalp", "tick_pct", "levels"):
-                                        if k in prof:
-                                            cfg[k] = prof[k]
-                                    save_markets()
+                                if want:
+                                    prof = cfg.get(f"profile_{want}") or {}
+                                    for k in ("tp", "sl", "rebuy_pct", "scalp", "tick_pct", "levels"):
+                                        if k in prof:
+                                            cfg[k] = prof[k]
+                                    save_markets()
 
                                     # üü¢ —è–∫—â–æ –º–æ–Ω–µ—Ç–∏ –±—É–ª–∏ ¬´–∑–∞–º–æ—Ä–æ–∂–µ–Ω—ñ¬ª –ø—ñ—Å–ª—è SL ‚Äî –≤—ñ–¥–Ω–æ–≤–ª—é—î–º–æ —Ç—ñ–ª—å–∫–∏ –Ω–∞ –∞–ø-—Ç—Ä–µ–Ω–¥—ñ
                                     if want == "up" and cfg.get("holdings_lock"):
                                         ok = await place_tp_sl_from_holdings(market, cfg)
                                         if ok and cfg.get("chat_id"):
                                             await bot.send_message(
                                                 cfg["chat_id"],
                                                 f"üü¢ {market}: –∞–ø-—Ç—Ä–µ–Ω–¥. –í—ñ–¥–Ω–æ–≤–ª–µ–Ω–æ: –≤–∏—Å—Ç–∞–≤–ª–µ–Ω–æ TP –≤—ñ–¥ —Ö–æ–ª–¥–∏–Ω–≥—ñ–≤."
                                             )
                                         cfg["holdings_lock"] = False
                                         save_markets()
@@
-                        if mode == "trigger" and cfg.get("entry_price"):
+                        if mode == "trigger" and cfg.get("entry_price"):
                             threshold = float(cfg["entry_price"]) * (1 - sl_pct / 100)
                         elif mode == "trailing" and cfg.get("peak"):
                             threshold = float(cfg["peak"]) * (1 - sl_pct / 100)
 
-                                                if threshold and lp <= threshold:
+                        if threshold and lp <= threshold:
                             # —Å–∫–∞—Å–æ–≤—É—î–º–æ –≤—Å—ñ –ª—ñ–º—ñ—Ç–∏
                             acts = await active_orders(market)
                             for o in acts.get("orders", []):
                                 oid = o.get("orderId") or o.get("id")
                                 if oid:
                                     await cancel_order(market, order_id=str(oid))
 
                             cfg["orders"].clear()
                             save_markets()
 
-                            base_av = await get_base_available(market)
-
-                            if cfg.get("hold_on_sl"):
-                                # ‚úÖ –ú º—è–∫–∏–π SL: –ù–ï –ø—Ä–æ–¥–∞—î–º–æ —Ä–∏–Ω–∫–æ–º, ¬´–∑–∞–º–æ—Ä–æ–∂—É—î–º–æ¬ª —Ö–æ–ª–¥–∏–Ω–≥ –¥–æ –∞–ø-—Ç—Ä–µ–Ω–¥—É
-                                cfg["holdings_lock"] = True
-                                save_markets()
-                                if cfg.get("chat_id"):
-                                    await bot.send_message(
-                                        cfg["chat_id"],
-                                        f"üü° {market}: SL-—Ç—Ä–∏–≥–µ—Ä. –ú–æ–Ω–µ—Ç–∏ –∑–∞–ª–∏—à–µ–Ω–æ (hold_on_sl=ON). –ß–µ–∫–∞—é –∞–ø-—Ç—Ä–µ–Ω–¥—É."
-                                    )
-                            else:
-                                # –∑–≤–∏—á–∞–π–Ω–∞ –ø–æ–≤–µ–¥—ñ–Ω–∫–∞: –ø—Ä–æ–¥–∞—Ç–∏ —Ä–∏–Ω–∫–æ–º —É—Å–µ
-                                if base_av > 0:
-                                    await place_market_order(market, "sell", float(base_av))
-                                    if cfg.get("chat_id"):
-                                        await bot.send_message(cfg["chat_id"], f"üõë {market}: SL —Å–ø—Ä–∞—Ü—é–≤–∞–≤, –ø—Ä–æ–¥–∞–Ω–æ —Ä–∏–Ω–∫–æ–º.")
-
-                            # —Å–∫–∏–Ω—É—Ç–∏ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å–∏
-                            cfg["entry_price"] = None
-                            cfg["peak"] = None
-                            save_markets()
-                            continue  # –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ—ó –ø–∞—Ä–∏
+                            base_av = await get_base_available(market)
+                            if cfg.get("hold_on_sl"):
+                                # ‚úÖ –ú º—è–∫–∏–π SL: –ù–ï –ø—Ä–æ–¥–∞—î–º–æ —Ä–∏–Ω–∫–æ–º, ¬´–∑–∞–º–æ—Ä–æ–∂—É—î–º–æ¬ª —Ö–æ–ª–¥–∏–Ω–≥ –¥–æ –∞–ø-—Ç—Ä–µ–Ω–¥—É
+                                cfg["holdings_lock"] = True
+                                save_markets()
+                                if cfg.get("chat_id"):
+                                    await bot.send_message(
+                                        cfg["chat_id"],
+                                        f"üü° {market}: SL-—Ç—Ä–∏–≥–µ—Ä. –ú–æ–Ω–µ—Ç–∏ –∑–∞–ª–∏—à–µ–Ω–æ (hold_on_sl=ON). –ß–µ–∫–∞—é –∞–ø-—Ç—Ä–µ–Ω–¥—É."
+                                    )
+                            else:
+                                # –∑–≤–∏—á–∞–π–Ω–∞ –ø–æ–≤–µ–¥—ñ–Ω–∫–∞: –ø—Ä–æ–¥–∞—Ç–∏ —Ä–∏–Ω–∫–æ–º —É—Å–µ
+                                if base_av > 0:
+                                    await place_market_order(market, "sell", float(base_av))
+                                    if cfg.get("chat_id"):
+                                        await bot.send_message(cfg["chat_id"], f"üõë {market}: SL —Å–ø—Ä–∞—Ü—é–≤–∞–≤, –ø—Ä–æ–¥–∞–Ω–æ —Ä–∏–Ω–∫–æ–º.")
+
+                            # —Å–∫–∏–Ω—É—Ç–∏ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å–∏
+                            cfg["entry_price"] = None
+                            cfg["peak"] = None
+                            save_markets()
+                            continue  # –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ—ó –ø–∞—Ä–∏
@@
                     if chat_id:
                         await bot.send_message(
                             chat_id=chat_id,
                             text=f"‚úÖ –û—Ä–¥–µ—Ä {finished_any['id']} ({market}, {finished_any['type']}) –∑–∞–∫—Ä–∏—Ç–æ!"
                         )
+
+                    # === AUTO-PAYOUT –ø—ñ—Å–ª—è TP ===
+                    try:
+                        if str(finished_any.get("type")) == "tp" and cfg.get("auto_payout_enabled"):
+                            tp_price = float(finished_any.get("price") or 0)
+                            tp_amount = float(finished_any.get("amount") or 0)
+                            if tp_price > 0 and tp_amount > 0:
+                                from decimal import ROUND_DOWN
+                                gross_usdt = Decimal(str(tp_price)) * Decimal(str(tp_amount))
+                                pct = Decimal(str(cfg.get("auto_payout_pct", 30.0)))
+                                pay = (gross_usdt * pct / Decimal("100")).quantize(Decimal("0.01"), rounding=ROUND_DOWN)
+                                pp = quote_step_from_rules(market)
+                                if pp > 0:
+                                    units = (pay / pp).to_integral_value(rounding=ROUND_DOWN)
+                                    pay = units * pp
+                                if pay > 0:
+                                    res = await transfer_trade_to_main_usdt(pay)
+                                    ok = isinstance(res, dict) and res.get("success") is not False
+                                    if ok and chat_id:
+                                        await bot.send_message(chat_id, f"üè¶ {market}: –∞–≤—Ç–æ-–≤–∏–≤—ñ–¥ {pay} USDT —É MAIN –≤–∏–∫–æ–Ω–∞–Ω–æ.")
+                                    elif not ok:
+                                        logging.warning(f"[PAYOUT] transfer failed: {res}")
+                    except Exception as e:
+                        logging.warning(f"[PAYOUT] error: {e}")e}")
